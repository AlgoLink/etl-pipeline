import luigi
from create_sensor_db import MySQLCreate
from datetime import datetime


# Luigi Task to populate a MySQL table with the data given in the sample dateset
class CreateDbFromCsv(luigi.Task):
    rundate = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    host = 'localhost'
    user = 'root'
    password = ''
    database = 'sensors'
    table = 'SensorTable'
    out_file = 'sql-db-{}.csv'.format(str(rundate))

    """Since it is the first task in the graph, it does not require any dependencies to finish before running"""
    def requires(self):
        return []

    """"Points to the location of the intermediary output of this task. In this case it is a local file"""
    def output(self):
        return luigi.LocalTarget(self.out_file)

    """Function that actually runs when the scheduler gives the Task permission to run
       The function creates the MySQL database, table and fills the table with data."""
    def run(self):
        mysql_db = MySQLCreate(host=self.host,
                               user=self.user,
                               password=self.password)
        mysql_db.fill_db(self.out_file)


# Luigi Task to generate a flattened version of the table generated by the previous table, where all
# three sensor readings for each minute in a single row together
class FlattenSqlDB(luigi.Task):
    rundate = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    host = 'localhost'
    user = 'root'
    password = ''
    out_file = 'output-{}.csv'.format(str(rundate))

    """Specifies that the task requires CreateDbFromCsv to finish before it can run"""
    def requires(self):
        return [CreateDbFromCsv()]

    """"Points to the location of the intermediary output of this task. In this case it is a local file"""
    def output(self):
        return luigi.LocalTarget(self.out_file)

    def run(self):
        mysql_db = MySQLCreate(host=self.host,
                               user=self.user,
                               password=self.password)
        db_connection = mysql_db.connection
        self.generate_flat_sensor_table(db_connection)
        self.write_flat_table_to_csv(db_connection, self.out_file)

    """Creates the flattened table, where one row shows the reading of all three sensors for a certain time."""
    @staticmethod
    def generate_flat_sensor_table(db_connection):
        with db_connection.cursor() as cursor:
            cursor.execute("use sensors")
            cursor.execute("drop table if exists `SensorsData`")
            # Join three different subsets of the `SensorTable`
            cursor.execute(
                "CREATE TABLE IF NOT EXISTS `SensorsData` (`Time` datetime, `DeviceID` INT ,`Sensor1Reading` INT, "
                "  `Sensor2Reading` INT, `Sensor3Reading` INT) "
                "SELECT S.Time, S.DeviceID, S.Reading as `Sensor1Reading`, T.Reading as `Sensor2Reading`, "
                "  U.Reading as `Sensor3Reading` "
                "FROM  (SELECT S.Time, S.DeviceID, S.Reading"
                "       FROM `SensorTable` S WHERE S.SensorID = 1) as S, "
                "(SELECT S.Time, S.DeviceID, S.Reading"
                "       FROM `SensorTable` S WHERE S.SensorID = 2) as T, "
                "(SELECT S.Time, S.DeviceID, S.Reading"
                "       FROM `SensorTable` S WHERE S.SensorID = 3) as U "
                "WHERE S.Time = T.Time and T.Time = U.Time and "
                " S.DeviceID = T.DeviceID and T.DeviceID = U.DeviceID;")

        db_connection.commit()

    """Write the entire new table into a csv file."""
    @staticmethod
    def write_flat_table_to_csv(db_connection, out_file):
        with db_connection.cursor() as cursor:
            cursor.execute("select * from `SensorsData`;")
            rows = cursor.fetchall()
            with open(out_file, "w") as out:
                out.write("Time, DeviceID, Sensor1 Reading, Sensor2 Reading, Sensor3 Reading")
                for row in rows:
                    out.write("\n")
                    time = row['Time'].strftime('%Y-%m-%d %H:%M')
                    device_id = row['DeviceID']
                    sensor1 = row['Sensor1Reading']
                    sensor2 = row['Sensor2Reading']
                    sensor3 = row['Sensor3Reading']
                    out.write("{}, {}, {}, {}, {}".format(time, device_id, sensor1, sensor2, sensor3))
        db_connection.commit()


if __name__ == '__main__':
    # Call on the last Task in the graph.
    luigi.run(["--local-scheduler"], main_task_cls=FlattenSqlDB)
